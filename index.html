<!DOCTYPE html>
<html lang="en">
<head>
  <title>Daived</title>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=0.5">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="description" content="Let's help you to know more about me">
  <meta name="keywords" content="Daived, about me, programmer, McDaived, Github">
  <meta name="author" content="Daived">
  <link rel="stylesheet" href="assets/css/main.css">
  <link rel="stylesheet" href="assets/css/main2.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Marvel">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="daived icon" type="png" href="assets/img/logo.png">
</head>
<body>
<div class="device-notification">
  <a class="device-notification--logo" href="">
    <img src="assets/img/logo.png" alt="Daived" width="30" height="30">
    <p>Daived</p>
  </a>
  <p class="device-notification--message">Daived has so much to offer that we must request you turn on rotation mode or find a larger screen. You won't be disappointed.</p>
</div>
<div class="perspective effect-rotate-left">
  <div class="container"><div class="outer-nav--return"></div>
    <div id="viewport" class="l-viewport">
      <div class="l-wrapper">
        <header class="header">
          <a class="header--logo" >
            <div class="brand">
<div class="logo">
  <svg width="200px" height="200px" >
        <path stroke="#ffffff" stroke-width="0" fill="#ffffff" d="M140.773,59.227C137.316,55.771,130.055,50,100,50
        s-37.317,5.771-40.774,9.227C55.77,62.684,49.999,69.104,50,100c-0.001,30.896,5.77,37.316,9.227,40.773
        C62.683,144.229,69.103,150,100,150c30.895,0,37.317-5.771,40.772-9.227C144.229,137.316,150,130.896,150,100
        S144.229,62.683,140.773,59.227z"/>
  
        <path stroke="#ffffff" stroke-width="0" fill="#ffffff" d="M140.773,59.227C137.316,55.771,130.055,50,100,50
        s-37.317,5.771-40.774,9.227C55.77,62.684,49.999,69.104,50,100c-0.001,30.896,5.77,37.316,9.227,40.773
        C62.683,144.229,69.103,150,100,150c30.895,0,37.317-5.771,40.772-9.227C144.229,137.316,150,130.896,150,100
        S144.229,62.683,140.773,59.227z"/>
  
        <path stroke="#ffffff" stroke-width="0" fill="#ffffff" d="M140.773,59.227C137.316,55.771,130.055,50,100,50
        s-37.317,5.771-40.774,9.227C55.77,62.684,49.999,69.104,50,100c-0.001,30.896,5.77,37.316,9.227,40.773
        C62.683,144.229,69.103,150,100,150c30.895,0,37.317-5.771,40.772-9.227C144.229,137.316,150,130.896,150,100
        S144.229,62.683,140.773,59.227z"/>
  </svg>
</div>
</div>
</a>
    <button class="header--cta cta">My Projects</button>
      <div class="header--nav-toggle">
         <span></span>
          </div>
        </header>
        <nav class="l-side-nav">
          <ul class="side-nav">
            <li class="is-active"><span>Home</span></li>
            <li><span>About Me</span></li>
            <li><span>Challenge</span></li>
            <li><span>Contact</span></li>
            <li><span>Projects</span></li>
          </ul>
        </nav>
        <ul class="l-main-content main-content">
          <li class="l-section section section--is-active">
 <div class="intro">
     <div class="intro--banner">
     <h1>
     <div>
	<span id="L">H</span>
	<span id="I">i</span>
	<span id="G">,</span>
	<span id="H">I</span>
    <span id="H">'</span>
	<span id="T">m</span>
    </div>
     </h1>
      <div class="element-to-resize">
         <div class="content">
         <h2>Daived</h2>
         <h2>Daived</h2>
     </div>
    </div>
    <button1 class="cta"><button class="btn-21">
  <span>My Projects</span>
</button>
   </button1>
    <img src="assets/img/daived.png" alt="Welcome">
         <img id="animatedImage" src="/assets/img/devil.gif" style="display: none;">
    </div>
<div class="intro--options">
    <ul id="circleSocial">
		<li><a href="https://www.instagram.com/eii3/"><span></span><span></span><span></span><span></span><span class="fab fa-instagram"></span></a></li>
		<li><a href="https://github.com/McDaived"><span></span><span></span><span></span><span></span><span class="fab fa-github"></span></a></li>
		<li><a href="https://t.me/Daiived"><span></span><span></span><span></span><span></span><span class="fab fa-telegram"></span></a></li>
		<li><a href="https://discord.com/users/314721544901361664"><span></span><span></span><span></span><span></span><span class="fab fa-discord"></span></a></li>
     </ul>


<button class="tip-button">
  <span class="tip-button__text">Send me a tip</span>
  <div class="coin-wrapper">
    <div class="coin">
      <div class="coin__middle"></div>
      <div class="coin__back"></div>
      <div class="coin__front"></div>
    </div>
  </div>
</button>

          
              
     <audio id="audio-player" autoplay name="audio-player" src="\assets\mp3\daived.mp3" ></audio>
<div>
    <label class="switch smiley">
        <input type="checkbox" unchecked>
        <span>ã…¤If you are happy <br>turn on god mode? </span>
        <svg viewBox="0 0 16 16">
            <circle cx="10.5" cy="5.5" r="1.5"></circle>
            <circle cx="5.5" cy="5.5" r="1.5"></circle>
            <path d="M1,3 C1.55228475,3 2,2.55228475 2,2 C2,1.63181017 1.66666667,0.9651435 1,0 C0.333333333,0.9651435 0,1.63181017 0,2 C0,2.55228475 0.44771525,3 1,3 Z"></path>
            <path d="M3,12.6 C4.66666667,11.1333333 6.33333333,10.4 8,10.4 C9.66666667,10.4 11.3333333,11.1333333 13,12.6"></path>
        </svg>
    </label>
</div>
</div>
</div>
</li>
<li class="l-section section">
<main>
    <canvas class="plane-canvas" id="plane-canvas"></canvas>
    <canvas class="main-canvas" id="main-canvas"></canvas>
    <div class="mouse" id="mouse">Hold mouse1 button</div>
    <div class="plate">
       <h2 class="text-animation" data-js="text">Iraqi Developer</h2>
       <p class="text-animation" data-js="text">Welcome To My World</p>
   </div>
   <div class='music-card playing'>
   <div class='image'></div>
   <div class='wave'></div>
   <div class='wave'></div>
   <div class='wave'></div>
   <div class='info'>
    <h2 class='title'>Loud and Heavy</h2>
    <div class='artist'>Listen With Me</div>
   </div>
  <i class="fa fa-pause trigger" aria-hidden="true"></i>
  <i class="fa fa-play trigger" aria-hidden="true"></i>
</div>
</main>
<div class="text"></div>
</li>
<li class="l-section section">
<div class="form-desktop"> 
<div id="container">
<div id="game"></div>
<div id="score">0</div>
<div id="instructions">Click (or press the spacebar) to place the block</div>
<div class="game-over">
		<h2>Game Over</h2>
		<p>You did great, you're the best.</p>
		<p>Click or spacebar to start again</p>
</div>
<div class="game-ready">
		<div id="start-button">Start</div>
		<div></div>
</div>
</div>
</div>
 </li>
<li class="l-section section">
<div class="card-container">
      <div class="card nitro-card">
        <div class="card-header">
          <div
            style="background: url('./assets/img/discord/banner.gif')"
            class="banner-img"
          ></div>
        </div>
        <div class="card-body">
          <div class="profile-header">
            <div class="profil-logo">
              <img src="./assets/img/discord/logo.png" />
            </div>
            <div class="badges-container">
                <div class="badge-item">
                <img src="./assets/img/discord/badges/HypeSquad_Balance.svg" alt="" />
                <div class="tooltip tooltip-up">HybeSquad Balance</div>
              </div>
                <div class="badge-item">
                <img src="./assets/img/discord/badges/Bug_Hunter_level2.svg" alt="" />
                <div class="tooltip tooltip-up">Discord Bug Hunter</div>
              </div>
              <div class="badge-item">
                <img src="./assets/img/discord/badges/Active_Developer.svg" alt="" />
                <div class="tooltip tooltip-up">Active Developer</div>
              </div>
                <div class="badge-item">
                <img src="./assets/img/discord/badges/Verified_Bot_Developer.svg" alt="" />
                <div class="tooltip tooltip-up">Early Verified Bot Developer</div>
              </div>
                <div class="badge-item">
                <img src="./assets/img/discord/badges/early_supporter.svg" alt="" />
                <div class="tooltip tooltip-up">Early Supporter</div>
              </div>
              <div class="badge-item">
                <img src="./assets/img/discord/badges/nitro.svg" alt="" />
                <div class="tooltip tooltip-up">Subscriber since Jan 10, 2016</div>
              </div>
                <div class="badge-item">
                <img src="./assets/img/discord/badges/boost24month.svg" alt="" />
                <div class="tooltip tooltip-up">Server boosting since Jan 12, 2016</div>
              </div>
              <div class="badge-item">
                <img src="./assets/img/discord/badges/user.svg" alt="" />
                <div class="tooltip tooltip-up">
                  Originally known as Daived#5653
                </div>
              </div>
            </div>
          </div>
          <div class="profile-body">
            <div class="username">
              <a> Daived </a>
            </div>
            <p> d11b </p>
            <hr/>
              <a href="https://github.com/McDaived" target="_blank" class="btn">Visit My Github</a>
            <div class="basic-infos">
              <div class="category-title">About Me</div>
              <p>
                 <b>Discord</b> Verified Account User <br>Joined since &rarr; 2016<br>
                 <b>Discord</b> Verified Active Developer<br> since &rarr; Oct 1, 2022 
              </p>
            </div>
            <div class="basic-infos">
              <div class="category-title">Member Since</div>
              <div style="display: flex; align-items: center;">
              <img src="https://i.ibb.co/HpbSK8B/icons8-discord-16.png" style="margin-right: 10px;">
                  <p style="margin: 0;">Jan 8, 2016</p>
            </div>
            </div>
            <div class="roles">
              <div class="category-title">Roles</div>
              <div class="roles-list">
                <div class="role">
                  <div class="role-color" style="background: lightyellow"></div>
                  <p>JavaScript</p>
                </div>
                <div class="role">
                  <div class="role-color" style="background: darkred"></div>
                  <p>HTML</p>
                </div>
                <div class="role">
                  <div class="role-color" style="background: darkgreen"></div>
                  <p>C++</p>
                </div>
                <div class="role">
                  <div class="role-color" style="background: yellow"></div>
                  <p>Python</p>
                </div>
                <div class="role">
                  <div class="role-color" style="background: darkblue"></div>
                  <p>C#</p>
                </div>
                <div class="role">
                  <div class="role-color" style="background: orange"></div>
                  <p>IT</p>
                </div>
                <div class="role role-add">
                  <div class="role-add-text">+</div>
                </div>
              </div>
            </div>
            <div class="note">
              <div class="category-title">Note</div>
              <textarea placeholder="Click for add a note">i know who you are, when send me messege</textarea>
            </div>
            <div class="message">
              <input id="content" type="text" placeholder="Send a message to @Daived"/>
            </div>
              <div id="message-status" style="display: none;"><b>Message Sent!</b></div>
          </div>
        </div>
      </div>
    </div>
</li>
          
            
            
            
<li class="l-section section">
<div class="work">
  <h2>My Projects</h2>
     <div class="work--lockup">
        <ul class="slider">
            <li class="slider--item slider--item-left">
               <a href="https://github.com/McDaived/Discord-Profile-Card">
                  <div class="slider--item-image">
                    <img src="https://github.com/McDaived/Discord-Profile-Card/assets/18085492/35ffced0-44dc-496c-88d2-a1c7a5be1d26" alt="Discord Profile Card">
                  </div>
                      <p class="slider--item-title">Discord Profile Card</p>
                      <p class="slider--item-description">An exact copy of discord profile card + webhook with 3 Cards <br><br> Send message with webhook - rolles  - Photo profile + Animation banner - Badges.</p>
               </a>
            </li>
            <li class="slider--item slider--item-center">
               <a href="https://github.com/McDaived/ValoDaiv">
                  <div class="slider--item-image">
                     <img src="assets/img/ValoDaiv.png">
                  </div>
                      <p class="slider--item-title">VALODAIV</p>
                      <p class="slider--item-description">Valorant API app<br><br> Edit Rank <br> Equip Any Skin <br> Instant Locker Agint </p>
               </a>
            </li>
            <li class="slider--item slider--item-right">
               <a href="https://github.com/McDaived/Valinfo">
                  <div class="slider--item-image">
                     <img src="assets/img/valinfo.png" alt="valinfo">
                 </div>
                      <p class="slider--item-title">VALINFO</p>
                      <p class="slider--item-description">Valorant API status <br><br>Status about valorant players<br> ranks, skins, win rate<br> and more..</p>
                    </a>
            </li>
            <li class="slider--item">
               <a href="https://github.com/McDaived/CS2-Patch-Access">
                  <div class="slider--item-image">
                    <img src="assets/img/cs2.png" alt="cs2">
                  </div>
                      <p class="slider--item-title">CS2 PATCH ACESS</p>
                      <p class="slider--item-description">App to download CS:2 on latest version and patch it to play with <br><br> friends - Custom Server - Offline <br> You cant play in official server.</p>
               </a>
            </li>
            <li class="slider--item">
                <a href="https://github.com/McDaived/CS2Downloader-Manifests">
                   <div class="slider--item-image">
                      <img src="assets/img/manifest.png" alt="manifest">
                      </div>
                      <p class="slider--item-title">CS2DOWNLOADER MANIFESTS</p>
                      <p class="slider--item-description"><br>Using the following method<br> you can download<br> Counter-Strike 2 game files <br>from official steam servers.</p>
                </a>
            </li>
            <li class="slider--item">
               <a href="https://github.com/McDaived/BFV-AimBot-V3">
                  <div class="slider--item-image">
                      <img src="assets/img/aimbot.png" alt="aimbot">
                  </div>
                      <p class="slider--item-title">BFV AIMBOT V3</p>
                      <p class="slider--item-description">Battlefield python aimbot <br><br> with new feature<br> Super antiBan - FairFight - <br> Strong aim</p>
                    </a>
            </li>
            <li class="slider--item">
               <a href="https://github.com/McDaived/BJump-AHK-CS2">
                  <div class="slider--item-image">
                      <img src="https://github.com/McDaived/BJump-AHK-CS2/assets/18085492/891e055e-d0ed-4205-bb52-39e561bde39b" alt="BJump AHK">
                  </div>
                      <p class="slider--item-title">BJump AHK Fast Bhop CS2</p>
                      <p class="slider--item-description">A simple script AutoHotKey to fast bhop in cs2 <br><br>Not bannable as it just use a AutoHotKey</p>
                    </a>
            </li>
            <li class="slider--item">
               <a href="https://github.com/McDaived/NoRecoil-CS2">
                  <div class="slider--item-image">
                      <img src="https://github.com/McDaived/NoRecoil-CS2/assets/18085492/87b1d566-b323-4a6d-a71c-334b76848eca" alt="AHK NoRecoil CS2">
                  </div>
                      <p class="slider--item-title">AHK NoRecoil CS2</p>
                      <p class="slider--item-description">A simple script AutoHotKey NoRecoil for CS2 <br><br>Not bannable as it just use a AutoHotKey</p>
                    </a>
            </li>
            </ul>
<div class="slider--prev">
                  <img src="assets/img/next-arrow-image.png" alt="Previous" />
</div>
<div class="slider--next">
                  <img src="assets/img/previous-arrow-image.png" alt="Previous" />
</div>
    </div>
</div>
</li>
</ul>
      </div>
    </div>
  </div>
  <ul class="outer-nav">
    <li class="is-active">Home</li>
    <li>About Me</li>
    <li>Challenge</li>
    <li>Contact</li>
    <li>Projects</li>
  </ul>
</div>
  <script src="assets/js/index.js"></script>
  <script src="https://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="assets/js/vendor/jquery-2.2.4.min.js"><\/script>')</script>
  <script src="assets/js/functions-min.js"></script>
<script>
const tipButtons = document.querySelectorAll('.tip-button')


tipButtons.forEach((button) => {
  let coin = button.querySelector('.coin')


  coin.maxMoveLoopCount = 90

  button.addEventListener('click', () => {
    if (button.clicked) return

    button.classList.add('clicked')


    setTimeout(() => {

      coin.sideRotationCount = Math.floor(Math.random() * 5) * 90
      coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI
      button.clicked = true
      flipCoin()
    }, 50)
  })

  const flipCoin = () => {
    coin.moveLoopCount = 0
    flipCoinLoop()
  }

  const resetCoin = () => {
    coin.style.setProperty('--coin-x-multiplier', 0)
    coin.style.setProperty('--coin-scale-multiplier', 0)
    coin.style.setProperty('--coin-rotation-multiplier', 0)
    coin.style.setProperty('--shine-opacity-multiplier', 0.4)
    coin.style.setProperty('--shine-bg-multiplier', '50%')
    coin.style.setProperty('opacity', 1)

    setTimeout(() => {
      button.clicked = false
    }, 300)
  }

  const flipCoinLoop = () => {
    coin.moveLoopCount++
    let percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount
    coin.angle = -coin.maxFlipAngle * Math.pow((percentageCompleted - 1), 2) + coin.maxFlipAngle
    

    coin.style.setProperty('--coin-y-multiplier', -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11)
    coin.style.setProperty('--coin-x-multiplier', percentageCompleted)
    coin.style.setProperty('--coin-scale-multiplier', percentageCompleted * 0.6)
    coin.style.setProperty('--coin-rotation-multiplier', percentageCompleted * coin.sideRotationCount)



    coin.style.setProperty('--front-scale-multiplier', Math.max(Math.cos(coin.angle), 0))
    coin.style.setProperty('--front-y-multiplier', Math.sin(coin.angle))

    coin.style.setProperty('--middle-scale-multiplier', Math.abs(Math.cos(coin.angle), 0))
    coin.style.setProperty('--middle-y-multiplier', Math.cos((coin.angle + Math.PI / 2) % Math.PI))

    coin.style.setProperty('--back-scale-multiplier', Math.max(Math.cos(coin.angle - Math.PI), 0))
    coin.style.setProperty('--back-y-multiplier', Math.sin(coin.angle - Math.PI))

    coin.style.setProperty('--shine-opacity-multiplier', 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2)
    coin.style.setProperty('--shine-bg-multiplier', -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + '%')


    if (coin.moveLoopCount < coin.maxMoveLoopCount) {
      if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add('shrink-landing')
      window.requestAnimationFrame(flipCoinLoop)
    } else {
      button.classList.add('coin-landed')
      coin.style.setProperty('opacity', 0)
      setTimeout(() => {
        button.classList.remove('clicked', 'shrink-landing', 'coin-landed')
        setTimeout(() => {
          resetCoin()
        }, 300)
      }, 1500)
    }
  }
})
</script>
  <script>
if(!CSS.supports('d', 'path("")')) {
    $('.switch.smiley').each(function(e) {
        var self = $(this);
        var input = self.children('input');
        self.find('svg path:last-child')[0].setAttribute('d', ((input.is(':checked')) ? 'M3,10.6 C4.66666667,11.8 6.33333333,12.4 8,12.4 C9.66666667,12.4 11.3333333,11.8 13,10.6' : 'M3,12.6 C4.66666667,11.1333333 6.33333333,10.4 8,10.4 C9.66666667,10.4 11.3333333,11.1333333 13,12.6'));
        input.change(function(e) {
            self.find('svg path:last-child')[0].setAttribute('d', ((input.is(':checked')) ? 'M3,10.6 C4.66666667,11.8 6.33333333,12.4 8,12.4 C9.66666667,12.4 11.3333333,11.8 13,10.6' : 'M3,12.6 C4.66666667,11.1333333 6.33333333,10.4 8,10.4 C9.66666667,10.4 11.3333333,11.1333333 13,12.6'));
        });
    });
}
document.addEventListener("DOMContentLoaded", function() {
  const audioPlayer = document.getElementById("audio-player");
  const toggleSwitch = document.querySelector(".smiley input");

  toggleSwitch.addEventListener("change", function() {
    if (this.checked) {
      audioPlayer.play();
    } else {
      audioPlayer.pause();
    }
  });
});    

/******************************************************/
 const checkbox = document.querySelector('input[type="checkbox"]');
 const animatedImage = document.getElementById('animatedImage');

    checkbox.addEventListener('change', function() {
        if (this.checked) {
            animatedImage.src = '/assets/img/devil.gif'; 
            animatedImage.style.display = 'block';
        } else {
            animatedImage.src = '';
            animatedImage.style.display = 'none';
        }
    });
/******************************************************/
</script>
    
<script>
const tools = {
  drawPath(ctx, fn) {
    ctx.save();
    ctx.beginPath();
    fn();
    ctx.closePath();
    ctx.restore();
  },
  random(min, max, int) {
    let result = min + Math.random() * (max + (int ? 1 : 0) - min);
    return int ? parseInt(result) : result;
  },
  getVectorLength(p1, p2) {
    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
  },
  easing(t, b, c, d, s) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  },
  cellEasing(t, b, c, d, s) {
    return c * (t /= d) * t * t * t + b;
  } };


const doc = {
  height: 0,
  width: 0 };


const plane = {
  xCell: 0,
  yCell: 0,
  cells: [] };


const context = {
  plane: null,
  main: null };


const mouse = {
  x: 0,
  y: 0,
  coords: {
    x: 0,
    y: 0 },

  down: {
    state: false,
    x: 0,
    y: 0 } };



const cfg = {
  cell: 35,
  sectionWidth: 8,
  sectionHeight: 1,
  numberOffset: 5,
  shadowBlur: true,
  bgColor: '#181818' };


const ui = {
  plane: '#plane-canvas',
  main: '#main-canvas',
  textNodes: '[data-js=text]',
  mouse: '#mouse' };


class App {
  constructor() {
    this.state = {
      area: 0,
      time: Date.now(),
      lt: 0,
      planeProgress: 0,
      dotsProgress: 0,
      fadeInProgress: 0,
      textProgress: 0,
      stepOffset: 0,
      textOffset: 0,
      markupOffset: 0,
      glitches: [],
      animLines: [],
      animNumbers: [],
      tabIsActive: true,
      planeIsDrawn: false,
      mousePower: 0,
      textPixelData: [],
      text: {},
      delta: 0,
      dlt: performance.now(),
      needRedraw: true };

    this.bindNodes();
    this.getDimensions();
    mouse.x = doc.width / 2;
    mouse.y = doc.height / 2;
    this.start();
  }
  start() {
    this.initEvents();
    this.canvasInit();
    this.loop();
    this.initCheckingInterval();
    this.splitText();
  }
  splitText() {
    ui.textNodes.forEach(el => {
      const value = el.innerText;
      el.innerHTML = value.split('').reduce((acc, cur) => {
        return acc + `<span class="letter">${cur}</span>`;
      }, '');
    });
  }
  animateText() {
    const callback = () => {
      ui.mouse.classList.add('active');
    };
    ui.textNodes.forEach((el, elIndex) => {
      el.classList.add('active');
      const letters = el.querySelectorAll('.letter');
      const length = Math.round(letters.length / 2) + 1;
      for (let i = 0; i < length; i++) {
        const [letter1, letter2] = [letters[i], letters[letters.length - i]];
        setTimeout(() => {
          if (letter1) letter1.classList.add('active');
          if (letter2) letter2.classList.add('active');
          if (i === length - 1 && elIndex === ui.textNodes.length - 1) callback();
        }, i * 100);
      }
    });
  }
  getDimensions() {
    doc.height = document.documentElement.clientHeight;
    doc.width = document.documentElement.clientWidth;
  }
  updatePlane() {

    const { width: w, height: h } = doc;

    const cell = Math.round(w / cfg.cell);

    const xPreSize = w / cell;
    plane.xCell = w / xPreSize % 2 !== 0 ? w / (w / xPreSize + 1) : xPreSize;

    const yPreSize = h / Math.round(cell * (h / w));
    plane.yCell = h / yPreSize % 2 !== 0 ? h / (h / yPreSize + 1) : yPreSize;

    plane.cells = [Math.round(w / plane.xCell), Math.round(h / plane.yCell)];
    plane.xCenter = Math.round(plane.cells[1] / 2);
    plane.yCenter = Math.round(plane.cells[0] / 2);
    plane.centerCoords = [plane.yCenter * plane.xCell, plane.xCenter * plane.yCell];

  }
  bindNodes() {
    for (const selector in ui) {
      ui[selector] = document.querySelectorAll(ui[selector]);
      if (ui[selector].length === 1) ui[selector] = ui[selector][0];
    }
  }
  canvasInit() {
    const font = '10px Montserrat';
    const lineCapAndJoin = 'round';
    const color = `rgba(255, 255, 255, 0.1)`;

    context.plane = ui.plane.getContext('2d');
    context.plane.lineCap = lineCapAndJoin;
    context.plane.lineJoin = lineCapAndJoin;
    context.plane.font = font;
    context.plane.fillStyle = color;
    context.plane.strokeStyle = color;

    context.main = ui.main.getContext('2d');
    context.main.lineCap = lineCapAndJoin;
    context.main.lineJoin = lineCapAndJoin;
    context.main.font = font;
    context.main.fillStyle = color;
    context.main.strokeStyle = color;

    this.getTextPixels();
  }
  initEvents() {

    window.addEventListener('resize', e => {
      this.getDimensions();
      this.resizeHandler(e);
    });
    document.addEventListener('mousemove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      mouse.coords = {
        x: (mouse.x / doc.width - 0.5) / 0.5,
        y: (mouse.y / doc.height - 0.5) / 0.5 * -1 };

    });
    document.addEventListener('mousedown', e => {
      mouse.down = {
        state: true,
        x: e.clientX,
        y: e.clientY };

    });
    document.addEventListener('mouseup', e => {
      mouse.down.state = false;
    });
    document.addEventListener('contextmenu', e => {
      e.preventDefault();
    });
    this.resizeHandler();

  }
  resizeHandler(e) {
    const state = this.state;
    state.area = doc.width * doc.height / 1000000;
    ui.main.height = doc.height;
    ui.main.width = doc.width;
    ui.plane.height = doc.height;
    ui.plane.width = doc.width;
    this.updatePlane();
    this.updateTextConfig();
    if (state.planeIsDrawn) this.getTextPixels();
    state.needRedraw = true;
  }
  updateTextConfig() {
    const state = this.state;
    state.text = {
      baseLine: 'top',
      font: '800 94px Montserrat',
      value: 'DAIVED' };

  }
  initCheckingInterval() {
    const state = this.state;
    setInterval(() => {
      state.tabIsActive = state.time <= state.lt ? false : true;
      state.lt = state.time;
      state.needRedraw = !state.tabIsActive;
    }, 100);
  }
  loop() {
    const loop = () => {
      const ctx = context.main;
      const state = this.state;
      state.time = Date.now();
      ctx.clearRect(0, 0, doc.width, doc.height);
      this.updateState();
      this.draw();
      if (state.needRedraw) state.needRedraw = false;
      this.raf = requestAnimationFrame(loop);
    };
    loop();
  }
  updateState() {
    const state = this.state;

    const now = performance.now();
    state.delta = now - state.dlt;
    state.dlt = now;

    const dt = state.delta;

    if (mouse.down.state) {
      state.mousePower += +0.001 * dt;
      if (state.mousePower >= 1) {
        state.mousePower = 1;
        ui.mouse.classList.remove('active');
      }
    } else {
      state.mousePower -= 0.001 * dt;
      if (state.mousePower <= 0) state.mousePower = 0;
    }

    const mp = tools.cellEasing(state.mousePower, 0, 1, 1);

    if (state.planeProgress >= 0.2) {
      state.dotsProgress += 0.00035 * dt;
      if (state.dotsProgress >= 1) state.dotsProgress = 1;
    }

    state.planeProgress += 0.00035 * dt;
    if (state.planeProgress >= 1) state.planeProgress = 1;

    if (state.planeIsDrawn) {

      state.fadeInProgress += 0.00015 * dt;
      if (state.fadeInProgress >= 1) state.fadeInProgress = 1;

      state.stepOffset += 0.002 * dt + mp * (0.0035 * dt);
      state.textOffset += 0.00005 * dt + mp * (0.002 * dt);
      state.markupOffset += 0.00015 * dt + mp * (0.00035 * dt);

      state.textProgress += 0.0005 * dt;
      if (state.textProgress >= 1) state.textProgress = 1;
    }
  }
  getTextPixels() {
    const ctx = context.main;
    const state = this.state;
    const { xCell, yCell } = plane;
    tools.drawPath(ctx, () => {
      ctx.fillStyle = 'white';
      ctx.textBaseline = state.text.baseLine;
      ctx.font = state.text.font;
      const text = state.text.value;
      const h = parseInt(ctx.font);
      const w = ctx.measureText(text).width;
      const x = doc.width / 2 - w / 2;
      const y = yCell * 2.75;
      ctx.fillText(text, x, y);
    });
    const imageData = ctx.getImageData(0, 0, doc.width, doc.height).data;
    state.textPixelData = [];
    const offset = 10;
    for (let h = 0; h < doc.height; h += offset) {
      for (let w = 0; w < doc.width; w += offset) {
        const pixel = imageData[(w + h * doc.width) * 4 - 1];
        if (pixel == 255) state.textPixelData.push({
          x: w,
          y: h,
          value: tools.random(0, 1, true) });

      }
    }
    ctx.clearRect(0, 0, doc.width, doc.height);
  }
  drawText() {

    const { yCell } = plane;
    const ctx = context.main;
    const state = this.state;
    const p = state.textOffset;
    const mp = tools.cellEasing(state.mousePower, 0, 1, 1);
    const length = state.textPixelData.length;

    tools.drawPath(ctx, () => {
      if (cfg.shadowBlur) {
        ctx.shadowColor = 'rgba(255,255,255,0.025)';
        ctx.shadowBlur = 30 * state.mousePower;
      }
      ctx.globalAlpha = state.fadeInProgress * 0.95;
      ctx.textBaseline = state.text.baseLine;
      ctx.fillStyle = cfg.bgColor;
      ctx.font = state.text.font;
      const text = state.text.value;
      const x = doc.width / 2 - ctx.measureText(text).width / 2;
      const y = yCell * 2.75;
      ctx.fillText(text, x, y);
    });

    for (let i = 0; i < state.textPixelData.length; i++) {
      const pixel = state.textPixelData[i];
      const { x, y, value } = pixel;
      const x2 = (3 + mp * 50) * Math.sin(p * i);
      const y2 = (10 + mp * 50) * Math.cos(p * i);
      const per = (1 - mp) * (i / length);
      tools.drawPath(ctx, () => {
        if (!per) return;
        ctx.globalAlpha = state.fadeInProgress;
        ctx.font = '8px Montserrat';

        ctx.fillStyle = `rgba(255,255,255,${per * 0.3})`;
        if (i % 2 === 0) ctx.fillText(value + '', x, y + y2 * -1);

        ctx.fillStyle = `rgba(255,255,255,${per})`;
        ctx.fillRect(x + x2, y, 5 * per * (1 - mp), 1);
        ctx.fillRect(x, y + y2, 1, 5 * per * (1 - mp));
      });
    }

  }
  draw() {

    const ctx = context.main;
    const state = this.state;

    const {
      xCell,
      yCell,
      xCenter,
      yCenter,
      cells } =
    plane;

    const cp = state.planeProgress;

    if (this.state.planeProgress >= 1 && !state.planeIsDrawn) {
      state.planeIsDrawn = true;
      this.startGeneratingGlitches();
      this.startGeneratingLines();
      this.startGeneratingNumbers();
      this.getTextPixels();
      this.animateText();
    }

    if (!state.planeIsDrawn || state.dotsProgress < 1 || state.planeIsDrawn && state.needRedraw) {
      this.drawPlane();
    }

    for (let i = 0; i < cells[0]; i++) {
      for (let i2 = 0; i2 < cells[1]; i2++) {

        const x = i * xCell;
        const y = i2 * yCell;

        if (state.planeIsDrawn) {
          this.drawMouseMoveInteraction({ i, i2, x, y });
          if (i2 === xCenter && i !== yCenter) {
            this.drawMarkupYAnimation({ i, i2, x, y, cp });
          }
          if (i2 !== xCenter && i === yCenter) {
            this.drawMarkupXAnimation({ i, i2, x, y, cp });
          }
        }

      }
    }

    if (state.planeIsDrawn) {
      this.drawGlitches();
      this.drawAnimLines();
      this.drawNumbersAnimation();
      this.drawText();
    }

  }
  startGeneratingNumbers() {
    const state = this.state;
    function generateItem() {
      const { cells, xCell, yCell } = plane;
      const mp = state.mousePower;
      const timeToNewItem = tools.random(
      1 + 50 * (1 - mp),
      5 + 100 * (1 - mp)) /
      state.area;
      const item = {
        p: 0,
        color: `rgba(255,255,255,${tools.random(0.01, 0.3)})`,
        blinks: Array(tools.random(0, 3, true)).fill(null).map(item => {
          return {
            at: tools.random(0, 1),
            dur: tools.random(0, 0.3) };

        }),
        pf: tools.random(0.00075, 0.01),
        x: tools.random(0, cells[0], true) * xCell,
        y: tools.random(0, cells[1], true) * yCell,
        value: tools.random(0, 1, true) };

      if (state.tabIsActive) state.animNumbers.push(item);
      setTimeout(generateItem, timeToNewItem);
    }
    generateItem();
  }
  drawNumbersAnimation() {
    const ctx = context.main;
    const state = this.state;
    const {
      yCell,
      xCell } =
    plane;
    state.animNumbers.forEach((item, i) => {
      item.p += item.pf * state.delta;
      let show = true;
      item.blinks.forEach(blink => {
        if (item.p >= blink.at && item.p <= blink.at + blink.dur) show = false;
      });
      if (!show) return;
      tools.drawPath(ctx, () => {
        if (cfg.shadowBlur) {
          ctx.shadowColor = 'white';
          ctx.shadowBlur = 10;
        }
        ctx.globalAlpha = state.fadeInProgress;
        ctx.textBaseline = 'top';
        ctx.font = '18px Montserrat';
        const th = parseInt(ctx.font) || 18;
        const tw = ctx.measureText(item.value + '').width;
        ctx.fillStyle = item.color;
        ctx.fillText(item.value + '', item.x + xCell / 2 - tw / 2, item.y + yCell / 2 - th / 2);
      });
      if (item.p >= 1) state.animNumbers.splice(i, 1);
    });
  }
  startGeneratingLines() {
    const state = this.state;
    function generateItem() {
      const { cells, xCell, yCell } = plane;
      const mp = state.mousePower;
      const timeToNewItem = tools.random(
      25 + 80 * (1 - mp),
      75 + 1200 * (1 - mp)) /
      state.area;
      const item = {
        p: 0,
        color: tools.random(0, 0.15),
        pf: tools.random(0.0005, 0.00125),
        x: tools.random(0, cells[0], true) * xCell,
        y: tools.random(0, cells[1], true) * yCell };

      item.coord = tools.random(0, 1, true) ? 'x' : 'y';
      item.length = tools.random(xCell * 2, state.area * xCell * 5);
      item.dir = tools.random(0, 1, true) ? 1 : -1;
      item.distance = item.length * tools.random(1, 2);
      if (state.tabIsActive) state.animLines.push(item);
      setTimeout(generateItem, timeToNewItem);
    }
    generateItem();
  }
  drawAnimLines() {
    const ctx = context.main;
    const state = this.state;
    state.animLines.forEach((line, i) => {

      line.p += line.pf * state.delta;
      const p = tools.easing(line.p, 0, 1, 1);

      const p1 = p / 0.5;
      const p2 = 1 - (p - 0.5) / 0.5;
      const color = `rgba(255,255,255,${0.1 + line.color * (p <= 0.5 ? p1 : p2)})`;

      const length = p <= 0.5 ? line.length * p1 : line.length * p2;
      const backwards = line.dir === -1;

      const isX = line.coord === 'x';
      const isY = line.coord === 'y';

      const x = !isX ? 0 : backwards ? -(length - line.distance * p) : -line.distance * p;
      const y = !isY ? 0 : backwards ? -(length - line.distance * p) : -line.distance * p;

      tools.drawPath(ctx, () => {
        ctx.globalAlpha = state.fadeInProgress;
        ctx.fillStyle = color;
        ctx.fillRect(
        line.x + x + (isX && p <= 0.5 ? (line.length - length) * line.dir : 0),
        line.y + y + (isY && p <= 0.5 ? (line.length - length) * line.dir : 0),
        isX ? length : 1,
        isY ? length : 1);

      });
      if (line.p >= 1) state.animLines.splice(i, 1);
    });
  }
  startGeneratingGlitches() {
    const state = this.state;
    function generateItem() {
      const { cells, xCell, yCell } = plane;
      const mp = state.mousePower;
      const timeToNewItem = tools.random(
      (5 + 100 * (1 - mp)) / state.area,
      (25 + 1200 * (1 - mp)) / state.area);

      const item = {
        p: 0,
        color: `rgba(255,255,255,${tools.random(0.01, 1)})`,
        blinks: Array(tools.random(0, 3, true)).fill(null).map(blink => {
          return {
            at: tools.random(0, 1),
            dur: tools.random(0, 0.3) };

        }),
        pf: tools.random(0.0015, 0.0035),
        x: tools.random(0, cells[0], true) * xCell,
        y: tools.random(0, cells[1], true) * yCell,
        width: xCell,
        height: yCell };

      if (state.tabIsActive) state.glitches.push(item);
      setTimeout(generateItem, timeToNewItem);
    }
    generateItem();
  }
  drawGlitches() {
    const ctx = context.main;
    const state = this.state;
    state.glitches.forEach((glitch, i) => {
      glitch.p += glitch.pf * state.delta;
      let show = true;
      glitch.blinks.forEach(blink => {
        if (glitch.p >= blink.at && glitch.p <= blink.at + blink.dur) show = false;
      });
      if (!show) return;
      tools.drawPath(ctx, () => {
        if (cfg.shadowBlur) {
          ctx.shadowColor = 'white';
          ctx.shadowBlur = 30;
        }
        ctx.globalAlpha = state.fadeInProgress;
        ctx.fillStyle = glitch.color;
        ctx.fillRect(glitch.x, glitch.y, glitch.width, glitch.height);
      });
      if (glitch.p >= 1) state.glitches.splice(i, 1);
    });
  }
  drawMouseMoveInteraction(props) {
    const ctx = context.main;
    const state = this.state;
    const fp = state.fadeInProgress;
    const sp = state.stepOffset;
    const mp = state.mousePower;
    const {
      xCenter,
      yCenter } =
    plane;
    const { i, i2, x, y } = props;
    const position = [Math.abs(i2 - xCenter), Math.abs(i - yCenter)];
    const mouseRange = (200 + 50 * mp) * (i * i2 % 2) * Math.sin(position[0] - position[1]);
    if (mouseRange <= 100) return;

    const vector = tools.getVectorLength([x, y], [mouse.x, mouse.y]);

    if (vector <= mouseRange) {

      const percent = (1 - vector / mouseRange) * fp;
      const spinRadius = 50 * (1 - percent);
      const xOffset = Math.sin(sp + i) * spinRadius * (Math.PI * 2 / 4) * ((i + i2) % 4 == 0 ? -1 : 1);
      const yOffset = Math.cos(sp + i2) * spinRadius * (Math.PI * 2 / 4);

      const sx = x + xOffset;
      const sy = y + yOffset;

      const radius = 25 * (1 - percent);
      const lineWidth = 3 + 10 * percent;


      const vector2 = tools.getVectorLength([sx, sy], [mouse.x, mouse.y]);
      const p2 = 1 - vector2 / (mouseRange + spinRadius * 2);

      const color = `rgba(255,255,255,${0.3 * percent})`;
      const color2 = `rgba(255,255,255,${0.7 * p2 * percent})`;

      tools.drawPath(ctx, () => {
        ctx.strokeStyle = color2;
        ctx.moveTo(sx, sy);
        ctx.lineTo(mouse.x, mouse.y);
        ctx.stroke();
      });
      tools.drawPath(ctx, () => {
        ctx.strokeStyle = color2;
        ctx.moveTo(x, y);
        ctx.lineTo(sx, sy);
        ctx.stroke();
      });
      tools.drawPath(ctx, () => {
        ctx.fillStyle = color;
        ctx.arc(x, y, 1, 0, 2 * Math.PI);
        ctx.fill();
      });
      tools.drawPath(ctx, () => {
        ctx.strokeStyle = `rgba(255,255,255,${0.5 * percent})`;
        ctx.lineWidth = 1 + 2 * (1 - percent);
        ctx.arc(x, y, 3 + 10 * (1 - percent), 0, 2 * Math.PI);
        ctx.stroke();
      });
      tools.drawPath(ctx, () => {
        ctx.fillStyle = `rgba(255,255,255,${percent})`;
        ctx.arc(sx, sy, 1, 0, 2 * Math.PI);
        ctx.fill();
      });
      tools.drawPath(ctx, () => {
        if (cfg.shadowBlur) {
          ctx.shadowColor = 'white';
          ctx.shadowBlur = radius;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = `rgba(255,255,255,${0.75 * percent})`;
        ctx.arc(sx, sy, radius, 0, 2 * Math.PI);
        ctx.stroke();
      });
    }

  }
  drawPlaneDotsAnimation(props) {
    const ctx = context.plane;
    const { dp, i, i2, x, y } = props;
    const {
      xCenter,
      yCenter } =
    plane;
    const position = [Math.abs(i2 - xCenter), Math.abs(i - yCenter)];
    const index = position[0] * position[1];
    const maxIndex = xCenter * yCenter;
    const percent = 1 / maxIndex;
    const point = percent * index;
    let f = dp * (dp / point);
    if (f >= 1) f = 1;
    const mf = f >= 0.5 ? (1 - f) / 0.5 : f / 0.5;
    const size = 3;
    if (!mf) return;
    tools.drawPath(ctx, () => {
      ctx.fillStyle = `rgba(255,255,255,${mf * 0.15})`;
      ctx.fillRect(x - 1, y - 1, size, size);
    });
  }
  drawPlaneCenterLines(props) {
    const { p } = props;
    const ctx = context.plane;
    const {
      centerCoords } =
    plane;
    tools.drawPath(ctx, () => {
      ctx.fillStyle = `rgba(255,255,255,${0.2 + (1 - p) * 1})`;
      ctx.fillRect(centerCoords[0], 0 + doc.height / 2 * (1 - p), 1, doc.height * p);
      ctx.fillRect(0 + doc.width / 2 * (1 - p), centerCoords[1], doc.width * p, 1);
    });
  }
  drawYLines(props) {
    const { i, cp, p, x } = props;
    const ctx = context.plane;
    const {
      yCenter } =
    plane;
    const percent = 1 / yCenter;
    const pos = Math.abs(i - yCenter);
    const point = percent * pos;
    let f = cp * (cp / point);
    if (f >= 1) f = 1;
    const ef = tools.cellEasing(f, 0, 1, 1);
    if (i) {
      tools.drawPath(ctx, () => {
        ctx.fillStyle = `rgba(255,255,255,${0.05 + (1 - p) * 0.35})`;
        ctx.fillRect(x, 0 + doc.height / 2 * (1 - ef), 1, doc.height * ef);
      });
    }
  }
  drawYMarkup(props) {
    const ctx = context.plane;
    const state = this.state;
    let { i, p, cp, x, y } = props;
    const {
      yCenter } =
    plane;
    const percent = 1 / yCenter;
    const pos = Math.abs(i - yCenter);
    const point = percent * pos;
    const conds = [p >= point, p <= point + percent];
    let f = cp * (cp / point);
    if (f >= 1) f = 1;
    const f2 = conds[0] && conds[1] ? (p - point) / percent : conds[0] ? 1 : 0;

    const text = i - yCenter + '';
    ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`;
    const textCoords = [x - ctx.measureText(text).width / 2, y + cfg.sectionWidth / 2 + cfg.numberOffset];
    tools.drawPath(ctx, () => {
      const o = (1 - f2) * 50;
      ctx.globalAlpha = f2;
      ctx.fillRect(x, y - cfg.sectionWidth / 2 + o, cfg.sectionHeight, cfg.sectionWidth);
    });
    tools.drawPath(ctx, () => {
      ctx.globalAlpha = f2;
      ctx.textBaseline = 'top';
      ctx.fillText(
      text,
      textCoords[0],
      textCoords[1] + (1 - f2) * -20);

    });
  }
  drawXLines(props) {
    const ctx = context.plane;
    const { i2, cp, p, y } = props;
    const {
      xCenter } =
    plane;
    const percent = 1 / xCenter;
    const pos = Math.abs(i2 - xCenter);
    const point = percent * pos;
    let f = cp * (cp / point);
    if (f >= 1) f = 1;
    const ef = tools.cellEasing(f, 0, 1, 1);
    if (i2) {
      tools.drawPath(ctx, () => {
        ctx.fillStyle = `rgba(255,255,255,${0.05 + (1 - p) * 0.35})`;
        ctx.fillRect(0 + doc.width / 2 * (1 - ef), y, doc.width * ef, 1);
      });
    }
  }
  drawXMarkup(props) {
    const ctx = context.plane;
    const state = this.state;
    let { i2, p, cp, x, y } = props;
    const {
      xCenter } =
    plane;

    const percent = 1 / xCenter;
    const pos = Math.abs(i2 - xCenter);
    const point = percent * pos;
    const conds = [p >= point, p <= point + percent];
    let f = cp * (cp / point);
    if (f >= 1) f = 1;
    let f2 = conds[0] && conds[1] ? (p - point) / percent : conds[0] ? 1 : 0;

    ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`;
    tools.drawPath(ctx, () => {
      const o = (1 - f2) * 50;
      ctx.globalAlpha = f2;
      ctx.fillRect(x - cfg.sectionWidth / 2 + o, y, cfg.sectionWidth, cfg.sectionHeight);
    });
    tools.drawPath(ctx, () => {
      ctx.globalAlpha = f2;
      ctx.textBaseline = 'middle';
      const textCoords = [x + cfg.sectionWidth / 2 + cfg.numberOffset, y + cfg.sectionHeight / 2];
      ctx.fillText(
      xCenter - i2 + '',
      textCoords[0] + (1 - f2) * -20,
      textCoords[1]);

    });
  }
  drawPlane() {

    const state = this.state;
    const ctx = context.plane;

    ctx.clearRect(0, 0, doc.width, doc.height);

    const {
      xCell,
      yCell,
      xCenter,
      yCenter,
      cells } =
    plane;

    const p = tools.easing(state.planeProgress, 0, 1, 1);
    const cp = state.planeProgress;
    const dp = state.dotsProgress;

    this.drawPlaneCenterLines({ p });

    for (let i = 0; i < cells[0]; i++) {
      for (let i2 = 0; i2 < cells[1]; i2++) {

        const x = i * xCell;
        const y = i2 * yCell;

        if (i !== yCenter && i2 !== xCenter) {
          this.drawPlaneDotsAnimation({ dp, i, i2, x, y });
        }
        if (i2 === xCenter && i !== yCenter) {
          this.drawYLines({ i, i2, p, cp, x, y });
          this.drawYMarkup({ i, p, cp, x, y });
        }
        if (i2 !== xCenter && i === yCenter) {
          this.drawXLines({ i, i2, p, cp, x, y });
          this.drawXMarkup({ i2, p, cp, x, y });
        }
      }
    }

  }
  drawMarkupYAnimation(props) {

    const ctx = context.main;
    const {
      yCenter } =
    plane;
    const { i, x, y } = props;

    const state = this.state;
    const spSin = Math.sin(state.markupOffset);
    const sp = spSin >= 0 ? tools.cellEasing(Math.abs(spSin), 0, 1, 1) : 0;

    const percent = 1 / yCenter;
    const pos = Math.abs(i - yCenter);
    const point = percent * pos;

    const f = sp >= point && sp <= point + percent ? (sp - point) / percent : 0;
    if (!f) return;

    const text = i - yCenter + '';

    ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`;
    const textCoords = [x - ctx.measureText(text).width / 2, y + cfg.sectionWidth / 2 + cfg.numberOffset];
    tools.drawPath(ctx, () => {
      ctx.fillStyle = `rgba(255,255,255,${f * 0.5})`;
      ctx.fillRect(x, y - cfg.sectionWidth / 2, cfg.sectionHeight, cfg.sectionWidth);
    });
    tools.drawPath(ctx, () => {
      if (cfg.shadowBlur) {
        ctx.shadowBlur = 5;
        ctx.shadowColor = 'white';
      }
      ctx.fillStyle = `rgba(255,255,255,${f * 0.35})`;
      ctx.textBaseline = 'top';
      ctx.fillText(
      text,
      textCoords[0],
      textCoords[1]);

    });
  }
  drawMarkupXAnimation(props) {

    const ctx = context.main;
    const state = this.state;
    let { i2, x, y } = props;
    const spSin = Math.sin(state.markupOffset);
    const sp = spSin <= 0 ? tools.cellEasing(Math.abs(spSin), 0, 1, 1) : 0;
    const {
      xCenter } =
    plane;

    const percent = 1 / xCenter;
    const pos = Math.abs(i2 - xCenter);
    const point = percent * pos;

    const f = sp >= point && sp <= point + percent ? (sp - point) / percent : 0;
    if (!f) return;

    tools.drawPath(ctx, () => {
      ctx.fillStyle = `rgba(255,255,255,${f * 0.5})`;
      ctx.fillRect(x - cfg.sectionWidth / 2, y, cfg.sectionWidth, cfg.sectionHeight);
    });

    tools.drawPath(ctx, () => {
      if (cfg.shadowBlur) {
        ctx.shadowBlur = 5;
        ctx.shadowColor = 'white';
      }
      ctx.fillStyle = `rgba(255,255,255,${f * 0.3})`;
      ctx.textBaseline = 'middle';
      const textCoords = [x + cfg.sectionWidth / 2 + cfg.numberOffset, y + cfg.sectionHeight / 2];
      ctx.fillText(
      xCenter - i2 + '',
      textCoords[0],
      textCoords[1]);

    });

  }}


window.addEventListener('load', () => {
  window.app = new App();
}); 
</script>
<script>
var audio = new Audio('https://cdn.discordapp.com/attachments/1115338067952283748/1143939040983384146/daived2.mp3');
audio.volume = 0.1;
audio.autoplay = false;

$('.trigger').click(function() {
  if (audio.paused == false) {
      audio.pause();
      $('.fa-play').show();
      $('.fa-pause').hide();
      $('.music-card').removeClass('playing');
  } else {
      audio.play();
      $('.fa-pause').show();
      $('.fa-play').hide();
      $('.music-card').addClass('playing');
  }
}); 
</script>
<script>
class TextScramble {
  constructor(el) {
    this.el = el
    this.chars = '!<>-_\\/[]{}â€”=+*^?#________'
    this.update = this.update.bind(this)
  }
  setText(newText) {
    const oldText = this.el.innerText
    const length = Math.max(oldText.length, newText.length)
    const promise = new Promise((resolve) => this.resolve = resolve)
    this.queue = []
    for (let i = 0; i < length; i++) {
      const from = oldText[i] || ''
      const to = newText[i] || ''
      const start = Math.floor(Math.random() * 80)
      const end = start + Math.floor(Math.random() * 80)
      this.queue.push({ from, to, start, end })
    }
    cancelAnimationFrame(this.frameRequest)
    this.frame = 0
    this.update()
    return promise
  }
  update() {
    let output = ''
    let complete = 0
    for (let i = 0, n = this.queue.length; i < n; i++) {
      let { from, to, start, end, char } = this.queue[i]
      if (this.frame >= end) {
        complete++
        output += to
      } else if (this.frame >= start) {
        if (!char || Math.random() < 0.28) {
          char = this.randomChar()
          this.queue[i].char = char
        }
        output += `<span class="dud">${char}</span>`
      } else {
        output += from
      }
    }
    this.el.innerHTML = output
    if (complete === this.queue.length) {
      this.resolve()
    } else {
      this.frameRequest = requestAnimationFrame(this.update)
      this.frame++
    }
  }
  randomChar() {
    return this.chars[Math.floor(Math.random() * this.chars.length)]
  }
}


const phrases = [
  'Hey,',
  'I AM IRAQI ',
  'PROGRAMMER ',
  'SECURITY RESEARCHER',
  'GAMER',
  'GAMES CREATER',
  'THX FOR VISITING MY WEBSITE',
  'HAVE FUN :)'
]

const el = document.querySelector('.text')
const fx = new TextScramble(el)

let counter = 0
const next = () => {
  fx.setText(phrases[counter]).then(() => {
    setTimeout(next, 2000)
  })
  counter = (counter + 1) % phrases.length
}

next()
    
</script>
<script>
    
"use strict";
console.clear();
class Stage {
    constructor() {
        this.render = function () {
            this.renderer.render(this.scene, this.camera);
        };
        this.add = function (elem) {
            this.scene.add(elem);
        };
        this.remove = function (elem) {
            this.scene.remove(elem);
        };
        this.container = document.getElementById('game');
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor('#080808', 1);
        this.container.appendChild(this.renderer.domElement);
        this.scene = new THREE.Scene();
        let aspect = window.innerWidth / window.innerHeight;
        let d = 20;
        this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, -100, 1000);
        this.camera.position.x = 2;
        this.camera.position.y = 2;
        this.camera.position.z = 2;
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));
        this.light = new THREE.DirectionalLight(0xffffff, 0.5);
        this.light.position.set(0, 499, 0);
        this.scene.add(this.light);
        this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(this.softLight);
        window.addEventListener('resize', () => this.onResize());
        this.onResize();
    }
    setCamera(y, speed = 0.3) {
        TweenLite.to(this.camera.position, speed, { y: y + 4, ease: Power1.easeInOut });
        TweenLite.to(this.camera.lookAt, speed, { y: y, ease: Power1.easeInOut });
    }
    onResize() {
        let viewSize = 30;
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.left = window.innerWidth / -viewSize;
        this.camera.right = window.innerWidth / viewSize;
        this.camera.top = window.innerHeight / viewSize;
        this.camera.bottom = window.innerHeight / -viewSize;
        this.camera.updateProjectionMatrix();
    }
}
class Block {
    constructor(block) {
        this.STATES = { ACTIVE: 'active', STOPPED: 'stopped', MISSED: 'missed' };
        this.MOVE_AMOUNT = 12;
        this.dimension = { width: 0, height: 0, depth: 0 };
        this.position = { x: 0, y: 0, z: 0 };
        this.targetBlock = block;
        this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
        this.workingPlane = this.index % 2 ? 'x' : 'z';
        this.workingDimension = this.index % 2 ? 'width' : 'depth';
        this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
        this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
        this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
        this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
        this.position.y = this.dimension.height * this.index;
        this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;
        this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random() * 100);
        if (!this.targetBlock) {
            this.color = 0x333344;
        }
        else {
            let offset = this.index + this.colorOffset;
            var r = Math.sin(0.3 * offset) * 55 + 200;
            var g = Math.sin(0.3 * offset + 2) * 55 + 200;
            var b = Math.sin(0.3 * offset + 4) * 55 + 200;
            this.color = new THREE.Color(r / 255, g / 255, b / 255);
        }

        this.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;

        this.speed = -0.1 - (this.index * 0.005);
        if (this.speed < -4)
            this.speed = -4;
        this.direction = this.speed;

        let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
        geometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
        this.material = new THREE.MeshToonMaterial({ color: this.color, shading: THREE.FlatShading });
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.set(this.position.x, this.position.y + (this.state == this.STATES.ACTIVE ? 0 : 0), this.position.z);
        if (this.state == this.STATES.ACTIVE) {
            this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
        }
    }
    reverseDirection() {
        this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed);
    }
    place() {
        this.state = this.STATES.STOPPED;
        let overlap = this.targetBlock.dimension[this.workingDimension] - Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
        let blocksToReturn = {
            plane: this.workingPlane,
            direction: this.direction
        };
        if (this.dimension[this.workingDimension] - overlap < 0.3) {
            overlap = this.dimension[this.workingDimension];
            blocksToReturn.bonus = true;
            this.position.x = this.targetBlock.position.x;
            this.position.z = this.targetBlock.position.z;
            this.dimension.width = this.targetBlock.dimension.width;
            this.dimension.depth = this.targetBlock.dimension.depth;
        }
        if (overlap > 0) {
            let choppedDimensions = { width: this.dimension.width, height: this.dimension.height, depth: this.dimension.depth };
            choppedDimensions[this.workingDimension] -= overlap;
            this.dimension[this.workingDimension] = overlap;
            let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
            placedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
            let placedMesh = new THREE.Mesh(placedGeometry, this.material);
            let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);
            choppedGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(choppedDimensions.width / 2, choppedDimensions.height / 2, choppedDimensions.depth / 2));
            let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);
            let choppedPosition = {
                x: this.position.x,
                y: this.position.y,
                z: this.position.z
            };
            if (this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane]) {
                this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane];
            }
            else {
                choppedPosition[this.workingPlane] += overlap;
            }
            placedMesh.position.set(this.position.x, this.position.y, this.position.z);
            choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);
            blocksToReturn.placed = placedMesh;
            if (!blocksToReturn.bonus)
                blocksToReturn.chopped = choppedMesh;
        }
        else {
            this.state = this.STATES.MISSED;
        }
        this.dimension[this.workingDimension] = overlap;
        return blocksToReturn;
    }
    tick() {
        if (this.state == this.STATES.ACTIVE) {
            let value = this.position[this.workingPlane];
            if (value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT)
                this.reverseDirection();
            this.position[this.workingPlane] += this.direction;
            this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
        }
    }
}
class Game {
    constructor() {
        this.STATES = {
            'LOADING': 'loading',
            'PLAYING': 'playing',
            'READY': 'ready',
            'ENDED': 'ended',
            'RESETTING': 'resetting'
        };
        this.blocks = [];
        this.state = this.STATES.LOADING;
        this.stage = new Stage();
        this.mainContainer = document.getElementById('container');
        this.scoreContainer = document.getElementById('score');
        this.startButton = document.getElementById('start-button');
        this.instructions = document.getElementById('instructions');
        this.scoreContainer.innerHTML = '0';
        this.newBlocks = new THREE.Group();
        this.placedBlocks = new THREE.Group();
        this.choppedBlocks = new THREE.Group();
        this.stage.add(this.newBlocks);
        this.stage.add(this.placedBlocks);
        this.stage.add(this.choppedBlocks);
        this.addBlock();
        this.tick();
        this.updateState(this.STATES.READY);
        document.addEventListener('keydown', e => {
            if (e.keyCode == 32)
                this.onAction();
        });
        document.addEventListener('click', e => {
            this.onAction();
        });
        document.addEventListener('touchstart', e => {
            e.preventDefault();

        });
    }
    updateState(newState) {
        for (let key in this.STATES)
            this.mainContainer.classList.remove(this.STATES[key]);
        this.mainContainer.classList.add(newState);
        this.state = newState;
    }
    onAction() {
        switch (this.state) {
            case this.STATES.READY:
                this.startGame();
                break;
            case this.STATES.PLAYING:
                this.placeBlock();
                break;
            case this.STATES.ENDED:
                this.restartGame();
                break;
        }
    }
    startGame() {
        if (this.state != this.STATES.PLAYING) {
            this.scoreContainer.innerHTML = '0';
            this.updateState(this.STATES.PLAYING);
            this.addBlock();
        }
    }
    restartGame() {
        this.updateState(this.STATES.RESETTING);
        let oldBlocks = this.placedBlocks.children;
        let removeSpeed = 0.2;
        let delayAmount = 0.02;
        for (let i = 0; i < oldBlocks.length; i++) {
            TweenLite.to(oldBlocks[i].scale, removeSpeed, { x: 0, y: 0, z: 0, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn, onComplete: () => this.placedBlocks.remove(oldBlocks[i]) });
            TweenLite.to(oldBlocks[i].rotation, removeSpeed, { y: 0.5, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn });
        }
        let cameraMoveSpeed = removeSpeed * 2 + (oldBlocks.length * delayAmount);
        this.stage.setCamera(2, cameraMoveSpeed);
        let countdown = { value: this.blocks.length - 1 };
        TweenLite.to(countdown, cameraMoveSpeed, { value: 0, onUpdate: () => { this.scoreContainer.innerHTML = String(Math.round(countdown.value)); } });
        this.blocks = this.blocks.slice(0, 1);
        setTimeout(() => {
            this.startGame();
        }, cameraMoveSpeed * 1000);
    }
    placeBlock() {
        let currentBlock = this.blocks[this.blocks.length - 1];
        let newBlocks = currentBlock.place();
        this.newBlocks.remove(currentBlock.mesh);
        if (newBlocks.placed)
            this.placedBlocks.add(newBlocks.placed);
        if (newBlocks.chopped) {
            this.choppedBlocks.add(newBlocks.chopped);
            let positionParams = { y: '-=30', ease: Power1.easeIn, onComplete: () => this.choppedBlocks.remove(newBlocks.chopped) };
            let rotateRandomness = 10;
            let rotationParams = {
                delay: 0.05,
                x: newBlocks.plane == 'z' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
                z: newBlocks.plane == 'x' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
                y: Math.random() * 0.1,
            };
            if (newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane]) {
                positionParams[newBlocks.plane] = '+=' + (40 * Math.abs(newBlocks.direction));
            }
            else {
                positionParams[newBlocks.plane] = '-=' + (40 * Math.abs(newBlocks.direction));
            }
            TweenLite.to(newBlocks.chopped.position, 1, positionParams);
            TweenLite.to(newBlocks.chopped.rotation, 1, rotationParams);
        }
        this.addBlock();
    }
    addBlock() {
        let lastBlock = this.blocks[this.blocks.length - 1];
        if (lastBlock && lastBlock.state == lastBlock.STATES.MISSED) {
            return this.endGame();
        }
        this.scoreContainer.innerHTML = String(this.blocks.length - 1);
        let newKidOnTheBlock = new Block(lastBlock);
        this.newBlocks.add(newKidOnTheBlock.mesh);
        this.blocks.push(newKidOnTheBlock);
        this.stage.setCamera(this.blocks.length * 2);
        if (this.blocks.length >= 5)
            this.instructions.classList.add('hide');
    }
    endGame() {
        this.updateState(this.STATES.ENDED);
    }
    tick() {
        this.blocks[this.blocks.length - 1].tick();
        this.stage.render();
        requestAnimationFrame(() => { this.tick(); });
    }
}
let game = new Game();

</script>
<script>
    
const profilLogo = document.querySelectorAll(".profil-logo");
const roleAdd = document.querySelectorAll(".role-add");
const input = document.querySelectorAll(".message input");

const randomHexColor = () => {
  return "#" + Math.floor(Math.random() * 16777215).toString(16);
};

const ramdomWord = () => {
  const words = [
    "Awesome",
    "Cool",
    "Great",
    "Nice",
    "Super",
    "Supernice",
    "Superior",
    "Wonderful",
    "Amazing",
    "Fantastic",
    "Fabulous",
    "Incredible",
    "Marvelous",
    "Spectacular",
    "Stupendous",
    "Terrific",
    "Astounding",
  ];
  return words[Math.floor(Math.random() * words.length)];
};

const addRole = (card) => {
  const role = document.createElement("div");
  const roleColor = document.createElement("div");
  const roleText = document.createElement("p");
  role.classList.add("role");
  roleColor.classList.add("role-color");
  roleColor.style.backgroundColor = randomHexColor();
  roleText.innerText = ramdomWord();
  role.append(roleColor, roleText);
  card.parentElement.append(role, card);
  removeRole();
};

const removeRole = () => {
  const roles = document.querySelectorAll(".role-color");
  roles.forEach((role) => {
    role.addEventListener("click", (e) => {
      e.target.parentElement.remove();
    });
  });
};

const toggleModal = () => {
  modal.classList.toggle("active");
};

profilLogo.forEach((logo) => {
  logo.addEventListener("click", toggleModal);
});

roleAdd.forEach((add) => {
  add.addEventListener("click", () => {
    addRole(add);
  });
});



removeRole();

$(function() {
    $('#content').keypress(function(e) {
        if (e.which === 13) { 
            e.preventDefault();
            
            var url = "https://discord.com/api/webhooks/1144631045493379162/xX9wsobqeSpGNAXXFiAnAf6_AfA3heUqH20jO82nVv_b1N1yr4UTq4YgzCVgxeFwTwLh";
            var content = $("#content").val();
            var username = "Daived Website Messege";
            var avatar_url = $("#avatar_url").val();
            
            $.post(url, {"content": content, "username": username, "avatar_url": avatar_url})
            .done(function() {
                
                $('#message-status').fadeIn().delay(2000).fadeOut();
                $("#content").val("");
            });
        }
    });
});
    
</script>
	</body>
</html>
